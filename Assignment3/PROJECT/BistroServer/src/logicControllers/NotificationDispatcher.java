package logicControllers;

import java.util.function.Consumer;

import dto.NotificationDTO;
import dto.NotificationDTO.Type;
import entities.Enums.Channel;
import entities.Notification;
import ocsf.server.ConnectionToClient;

/**
 * Dispatches notifications to users through different simulated channels (SMS /
 * EMAIL).
 * <p>
 * This class is responsible for delivering notifications that were previously
 * scheduled or generated by the system. Delivery is simulated using:
 * <ul>
 * <li>Server-side logging for EMAIL notifications</li>
 * <li>Client popups for SMS notifications when the user is online</li>
 * </ul>
 * </p>
 * <p>
 * The dispatcher relies on {@link OnlineUsersRegistry} to determine whether a
 * user is currently connected, and uses a {@link Consumer} logger instead of
 * direct console output.
 * </p>
 */
public class NotificationDispatcher {

	private final OnlineUsersRegistry onlineUsers;
	private final Consumer<String> logger;

	/**
	 * Constructs a NotificationDispatcher with required dependencies.
	 *
	 * @param onlineUsers registry used to resolve online users and their
	 *                    connections
	 * @param logger      callback used for logging simulated notification delivery
	 */
	public NotificationDispatcher(OnlineUsersRegistry onlineUsers, Consumer<String> logger) {
		this.onlineUsers = onlineUsers;
		this.logger = logger;
	}

	/**
	 * Dispatches a notification according to its configured delivery channel.
	 * <p>
	 * Behavior by channel:
	 * <ul>
	 * <li><b>EMAIL</b>: logged only (delivery is simulated server-side)</li>
	 * <li><b>SMS</b>: sent as a popup notification to the client if the user is
	 * online</li>
	 * </ul>
	 * </p>
	 * <p>
	 * For SMS notifications, a safe display message is shown in the UI, while the
	 * full message content is preserved in the simulated SMS body.
	 * </p>
	 *
	 * @param n the notification entity to dispatch
	 */
	public void dispatch(Notification n) {

		// EMAIL simulation -> log only (and mark as sent by scheduler)
		if (n.getChannel() == Channel.EMAIL) {
			logger.accept("üìß EMAIL-SIM | userId=" + n.getUserId() + " | " + n.getMessage());
			return;
		}

		// SMS simulation -> popup (safe text) + channel message (full SMS content)
		if (n.getChannel() == Channel.SMS) {
			ConnectionToClient client = onlineUsers.getClient(n.getUserId());

			if (client == null) {
				logger.accept("üì© SMS-SIM (OFFLINE) | userId=" + n.getUserId() + " | " + n.getMessage());
				return;
			}

			try {
				Type popupType = Type.INFO;

				// Safe popup text (NO code / sensitive details)
				String displayMessage = getSafeDisplayMessage(n);

				// The actual simulated SMS body (can include the code)
				String smsBody = n.getMessage();

				client.sendToClient(new NotificationDTO(popupType, "SMS", displayMessage, smsBody));

				logger.accept("üì© SMS-SIM (SENT) | userId=" + n.getUserId() + " | " + smsBody);

			} catch (Exception e) {
				logger.accept("‚ùå SMS-SIM error | userId=" + n.getUserId() + " | " + e.getMessage());
			}
		}
	}

	/**
	 * Generates a safe user-facing message for popup notifications.
	 * <p>
	 * This method ensures that sensitive information (such as confirmation codes)
	 * is not displayed directly in the UI. The returned text depends on the
	 * notification type.
	 * </p>
	 *
	 * @param n the notification entity
	 * @return a safe display message suitable for UI popups
	 */
	private String getSafeDisplayMessage(Notification n) {

		switch (n.getNotificationType()) {

		case RESEND_CONFIRMATION_CODE:
			return "Verification code has been sent via SMS.";

		case RESERVATION_REMINDER_2H:
			return "Reminder: your reservation is in 2 hours.";

		case TABLE_AVAILABLE:
			return "A table is now available. Please arrive within 15 minutes to avoid cancellation.";

		case BILL_AFTER_2H_FROM_CHECKIN:
			return "Your bill details have been sent via SMS.";

		case RESERVATION_CANCELLED_OPENING_HOURS:
			return "Your reservation was cancelled due to a change in opening hours.";

		case MONTHLY_REPORT_READY:
			return "Monthly report for the previous month is now available.";

		case RESERVATION_CANCELLED:
			return "Your reservation was cancelled.";

		default:
			return "You have a new notification.";
		}
	}
}
